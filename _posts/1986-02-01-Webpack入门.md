---
layout: post
title: Webpack入门
tags: Webpack
categories: Tooles
---


## 什么是 Webpack 

js 代码的模块打包工具(原初) → →  前端代码的管理工具.(现在)

- 旧方式: html css js 都是分离的.必须分别对每一项进行管理.







## 安装和配置

一: 全局安装
1. 安装 webpack 全局环境 : 
		npm install webpack -g
2. 查看 webpack 版本:
		webpack -v

> webpack 是 node 项目. 确保电脑有安装 node.js & npm 



二: 项目安装
1. 进入项目
2. 确保有 package.json (没有就 npm init 一路回车来创建.)
3. 安装 webpack 依赖
	npm install webpack --save-dev
	
	// 下面是上面命令的缩写( 选一个就行.)
	// -save :     模块名将被添加到dependencies.    可以简化成参数 -S
	// -save-dev:  模块名将被添加到devDependencies，可以简化为参数 -D
	npm i webpack -D



package.json 参考:

	{
	  "name": "first-demo",
	  "version": "1.0.0",
	  "description": "this is my first-demo",
	  "main": "index.js",
	  "scripts": {
	"test": "echo \"Error: no test specified\" && exit 1"
	  },
	  "author": "guowenfh",
	  "license": "MIT",
	  "dependencies": {},
	  "devDependencies": {
	"webpack": "^1.12.14"
	  }
	}











2. 配置

每个项目下都必须有一个配置文件: webpack.config.js
告诉webpack 需要做什么.




安装











### 第一步
使用 yarn 来替代 npm (两个功能一样 但是教程用的是 yarn...)
	brew install yarn

1. 打来到项目文件夹
2. 运行下面 添加 webpack2 到全局 和 本地项目.


	yarn global add webpack@2.1.0-beta.25 webpack-dev-server@2.1.0-beta.10
	yarn add --dev webpack@2.1.0-beta.25 webpack-dev-server@2.1.0-beta.10



3. 根目录 新建一个 webpack.config.js 文件用来声明 Webpack 的配置：

	'use strict';
	
	const webpack = require("webpack");
	
	module.exports = {
	  context: __dirname + "/src",
	  entry: {
	app: "./app.js",
	  },
	  output: {
	path: __dirname + "/dist",
	filename: "[name].bundle.js",
	  },
	};







#### 多个文件一个输出
所有文件会按数组顺序一起打包到 dist/app.bundle.js 一个文件当中。
	'use strict';
	
	const webpack = require("webpack");
	
	module.exports = {
	  context: __dirname + "/src",
	  entry: {
	app: ["./home.js", "./events.js", "./vendor.js"],
	  },
	  output: {
	path: __dirname + "/dist",
	filename: "[name].bundle.js",
	  },
	};



#### 多个文件多个输出
打包成三个文件：dist/home.bundle.js、dist/events.bundle.js 和 dist/contact.bundle.js。
	const webpack = require("webpack");
	
	module.exports = {
	  context: __dirname + "/src",
	  entry: {
	home: "./home.js",
	events: "./events.js",
	contact: "./contact.js",
	  },
	  output: {
	path: __dirname + "/dist",
	filename: "[name].bundle.js",
	  },
	};






## webpack 本地开发

只需要在 webpack.config.js 里添加一个 devServer 对象：


	module.exports = {
	  context: __dirname + "/src",
	  entry: {
	app: "./app.js",
	  },
	  output: {
	filename: "[name].bundle.js",
	path: __dirname + "/dist/assets",
	publicPath: "/assets",            // New
	  },
	  devServer: {
	contentBase: __dirname + "/src",  // New
	  },
	};



现在新建一个 src/index.html 文件，加入下面这行：

	<script src="/assets/app.bundle.js"></script>


然后在命令行中，运行：

webpack-dev-server

服务器现在就运行在了 localhost:8080 上。注意 script 标签中的 /assets 对应的是 output.publicPath的值 - 可以随便填成你想要的命名（如果需要一个 CDN，这就很有用了）。




当你更改 JavaScript 代码的时候，Webpack 就会实时更新页面而无需手动刷新浏览器。但是，任何对webpack.config.js 的更改都需要重启服务器才可以生效。









## loaders


目前为止，我们所讲到的都是关于 JavaScript 代码的使用。从 JavaScript 代码开始是非常重要的，因为这是 Webpack 唯一使用的语言。我们可以处理任何文件类型，只要将它们传进 JavaScript 代码中。这个功能用 Loaders 来实现。



一个 loader 可以指向一个像 Sass 的预处理器，或者像 Babel 的编译器。在 NPM 中，它们通常是像 sass-loader或 babel-loader 这样命名为 *-loader。*





### Babel + ES6 
如果我们想要在项目中通过 Babel 来使用 ES6，首先要在本地正确地安装一些 loader：

	yarn add --dev babel-loader babel-core babel-preset-es2015

…然后把它们添加进 webpack.config.js 好让 Webpack 知道哪里使用它们。

	module.exports = {
	  // …
	  module: {
	rules: [
	  {
	test: /\.js$/,
	use: [{
	  loader: "babel-loader",
	  options: { presets: ["es2015"] }
	}],
	  },
	
	  // Loaders for other file types can go here
	],
	  },
	  // …
	};


	这样做就可以为 /\.js$/ 正则表达式寻找以 .js 结尾的文件，最后通过 Babel 编译加载。Webpack 依赖正则表达式给予你完整的控制 - 但它不会限制你的文件后缀，或者假设你的代码必须以某种特定形式组织起来。举个例子：也许你的 /my_legacy_code/ 文件夹里的代码不是用 ES6 写的，那么你就可以把上面的 test 修改为 /^((?!my_legacy_code).)*\.js$/，这样就可以绕过这个文件夹，其余文件用 Babel 编译。







## CSS + Loader
如果我们只想加载应用需要的 CSS，也可以那么做。假设有一个 index.js 文件，在里面引入：

	import styles from './assets/stylesheets/application.css';

就会得到一个错误：You may need an appropriate loader to handle this file type。记住 Webpack 只能读取 JavaScript，所以我们必须安装正确的 loader：


	yarn add --dev css-loader style-loader


	module.exports = {
	  // …
	  module: {
	rules: [
	  {
	test: /\.css$/,
	use: ["style-loader", "css-loader"],
	  },
	  // …
	],
	  },
	};



这些 loader 会以数组逆序运行。这意味着 css-loader 会在 style-loader 之前运行。






从 JS 里加载 CSS 相当爽，因为你可以用一种强有力的新方式去模块化 CSS 代码了。
假设你只通过 button.js 加载了 button.css，这就意味着如果 button.js 没有实际用到的话，它的 CSS 也不会打包进我们的生产构建结果。
如果你坚持使用像 SMACSS 或者 BEM 那样的面向组件的 CSS，就会知道把 CSS 和 HTML + JavaScript 代码放更近的价值了。









## Sass
	yarn add --dev sass-loader node-sass

然后添加另一条规则：

	module.exports = {
	  // …
	  module: {
	rules: [
	  {
	test: /\.(sass|scss)$/,
	use: [
	  "style-loader",
	  "css-loader",
	  "sass-loader",
	]
	  }
	  // …
	],
	  },
	};

接下来当 JavaScript 调用 import 引入一个 .scss 或 .sass 文件时，Webpack 就会做它该做的事情了。









## 分开打包css
或许你正在处理渐进式增强的网站，又或许因为其他的原因你需要一个分离的 CSS 文件。我们可以简单地实现，只需要在配置里用 extract-text-webpack-plugin 替换掉 style-loader，而无需改变其他任何代码。以 app.js文件为例：


import styles from './assets/stylesheets/application.css';


本地安装插件（我们需要这个的测试版本，2016年10月发布）：

yarn add --dev extract-text-webpack-plugin@2.0.0-beta.4

添加到 webpack.config.js：

	const ExtractTextPlugin = require("extract-text-webpack-plugin");
	module.exports = {
	  // …
	  module: {
	rules: [
	  {
	test: /\.css$/,
	loader:  ExtractTextPlugin.extract({
	  loader: 'css-loader?importLoaders=1',
	}),
	  },
	
	  // …
	]
	  },
	  plugins: [
	new ExtractTextPlugin({
	  filename: "[name].bundle.css",
	  allChunks: true,
	}),
	  ],
	};


现在运行 webpack -p 的时候就可以看到一个 app.bundle.css 文件出现在 output 目录里了。像往常一样简单地添加一个 \<link\> 标签到 HTML 文件里就可以了。







## webpack 思考方式
为了最大程度发挥 Webpack 的作用，你不得不从模块的角度去思考（小、可复用、自包含进程），一件件事情慢慢去做好。这意味着下面这样的东西



	└── js/
	└── application.js   // 300KB of spaghetti code
	
	一起的js 变成下面的js
	
	└── js/
	├── components/
	│   ├── button.js
	│   ├── calendar.js
	│   ├── comment.js
	│   ├── modal.js
	│   ├── tab.js
	│   ├── timer.js
	│   ├── video.js
	│   └── wysiwyg.js
	│
	└── application.js  // ~ 1KB of code; imports from ./components/



结果是干净且可复用的代码。每个独立的组件取决于导入自身的依赖，并按照它想要的方式导出到其他模块。配合 Babel + ES6 使用，还可以利用 JavaScript Classes 做出更好的模块化，并且不要去想它，作用域只是在起作用。



















模块加载器 & 打包工具.

能把各种资源(js, coffee, css,less,sass, 图片) 等等都作为模块来使用和处理.



直接使用 require(xxx) 来引入模块.
即使某些需要经过编译(sass等)才能用.也不用太费心思.



主流项目 都是 基于 webpack 开发啊.




## webpack 优势

使用 commonJS 格式来写脚本.
扩展性能强.









### 配置示例
	var webpack = require('webpack');
	var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');
	
	module.exports = {
	//插件项
	plugins: [commonsPlugin],
	//页面入口文件配置
	entry: {
	index : './src/js/page/index.js'
	},
	//入口文件输出配置
	output: {
	path: 'dist/js/page',
	filename: '[name].js'
	},
	module: {
	//加载器配置
	loaders: [
	{ test: /\.css$/, loader: 'style-loader!css-loader' },
	{ test: /\.js$/, loader: 'jsx-loader?harmony' },
	{ test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
	{ test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
	]
	},
	//其它解决方案配置
	resolve: {
	root: 'E:/github/flux-example/src', //绝对路径
	extensions: ['', '.js', '.json', '.scss'],
	alias: {
	AppStore : 'js/stores/AppStores.js',
	ActionType : 'js/actions/ActionType.js',
	AppAction : 'js/actions/AppAction.js'
	}
	}
	};



#### 一: plugins: 插件.
后面是插件名字.




#### 二: entry output
entry: 页面入口文件配置.
output:  输出配置

也就是 入口文件最终要生成什么名字的文件.
存放在哪里.

##### entry output 语法:
	{
	entry: {
	page1: "./page1",
	//支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出
	page2: ["./entry1", "./entry2"]
	},
	output: {
	path: "dist/js/page",
	filename: "[name].bundle.js"
	}
	}

该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。


#### 三: module.loaders
最关键的配置.
告诉webpack 每种文件都用什么加载器来处理.


	module: {
	//加载器配置
	loaders: [
	//.css 文件使用 style-loader 和 css-loader 来处理
	{ test: /\.css$/, loader: 'style-loader!css-loader' },
	//.js 文件使用 jsx-loader 来编译处理
	{ test: /\.js$/, loader: 'jsx-loader?harmony' },
	//.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理
	{ test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
	//图片文件使用 url-loader 来处理，小于8kb的直接转为base64
	{ test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
	]
	}

注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。
拿最后一个 url-loader 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：
	npm install url-loader -save-dev
配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。


#### 四: resolve 配置
	resolve: {
	//查找module的话从这里开始查找
	root: 'E:/github/flux-example/src', //绝对路径
	//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名
	extensions: ['', '.js', '.json', '.scss'],
	//模块别名定义，方便后续直接引用别名，无须多写长长的地址
	alias: {
	AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可
	ActionType : 'js/actions/ActionType.js',
	AppAction : 'js/actions/AppAction.js'
	}
	}








## 运行 webpack
	$ webpack --display-error-details

后面的参数“--display-error-details”是推荐加上的，
方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。


webpack 参数
	$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包
	
	$ webpack --watch   //监听变动并自动打包
	
	$ webpack -p    //压缩混淆脚本，这个非常非常重要！
	
	$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了


其中的 -p 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）。







## 模块引入



### HTML 模块引入
	<!DOCTYPE html>
	<html>
	<head lang="en">
	  <meta charset="UTF-8">
	  <title>demo</title>
	</head>
	<body>
	  <script src="dist/js/page/common.js"></script>
	  <script src="dist/js/page/index.js"></script>
	</body>
	</html>

body 最后的 js  直接写 webpack 最终生成的文件就可以了.
CSS 都不用写!! 因为帮你直接内建到 成html内联样式了..



### JS 模块引入

直接使用 commonJS 来写.
还可以引入未编译的模块 如 sass. coffee.
(只要你在 webpack.config.js 里配置好了对应的加载器)



页面入口文件(index.js)
	require('../../css/reset.scss'); //加载初始化样式
	require('../../css/allComponent.scss'); //加载组件样式
	var React = require('react');
	var AppWrap = require('../component/AppWrap'); //加载组件
	var createRedux = require('redux').createRedux;
	var Provider = require('redux/react').Provider;
	var stores = require('AppStore');
	
	var redux = createRedux(stores);
	
	var App = React.createClass({
	render: function() {
	return (
	<Provider redux={redux}>
	{function() { return <AppWrap />; }}
	</Provider>
	);
	}
	});
	
	React.render(
	<App />, document.body
	);


























































