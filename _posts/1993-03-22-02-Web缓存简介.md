---
layout: post
title:  ❤️Web缓存简介❤️
tags: 缓存
categories: Web
---


## ‼️缓存背景详解:

- H5 新实习员工:  ServiceWorker
	> 试验功能(新实习员工:试用中). 字面意思: 服务工人 → 服务员 
- H5 老员工:  Web Worker: 
- Boss:      浏览器
	> 准确来说，每个页面的javascript运行主线程都是一个Boss。


### 缓存大背景。
**Boss很厉害，在页面上指点江山，呼风唤雨。但他有个局限：同一时刻只做一件事（单线程）。**


当一些很耗时的杂事让Boss去处理时，在处理的过程中他就无暇顾及其它重要的事了。
在用户看来，页面没人管了，Boss不干事了！这时Boss就很郁闷。

为了保证Boss能处理更重要的事情，董事会（W3C）终于招聘了一个新员工：Web worker。
这下，Boss终于可以从耗时的杂事中解放出来了，他只需要把Web worker叫过来说：“这些事情拿去做，没做完不要来找我”。
Web worker领到任务后默默地到自己的工位（线程）去干活，完成之后给Boss发了个邮件（postMessage）。
Boss收到邮件（onmessage）后欣慰地点了点头。

扯了半天好像还没谈到新员工啊。。。不急，下面就讲到了。
Boss下班了（页面关闭）,Web worker也收拾东西回家了。
这样执行了很久，直至2014年6月，董事会发现一个问题：“居然没有人在老板下班后加班？”。
于是，又招了一个专职加班的：Service Worker。
它被赋予的绩效目标如下：
.	入职（install）后永不下班，而能更新。
.	能处理Boss需要的资源（HTTPS请求），以便离线时也能让BOSS取到数据（从cache中）。
.	能向客户推送消息(push notifications)
.	不允许越权管理Boss的事（DOM ACCESS）
总地来说，Service worker是独立于页面的一个运行环境，它在页面关闭后仍可以运行。
同时，也能对它负责的页面的网络请求进行截取和返回请求（类似于Fiddler）。













**manifest. 废弃中!!!! 使用 Service Workers 替代.**
**manifest. 废弃中!!!! 使用 Service Workers 替代.**
**manifest. 废弃中!!!! 使用 Service Workers 替代.**


[Service Worker 文档][1]
[Manifest 文件 (强烈不建议使用)][2]
> AppCache — 看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。    
> 但是，这个方法假定了你使用时会遵循很多规则，如果你不严格遵循这些规则，它会把你的APP搞得一团糟!!!!!  
> 就像我的博客. 主页居然被缓存了.. 根本没有设置过....  









## 离线存储技术简介

** 数据缓存分为两种：AppCache & DOM/Web Storage.**

**Web Storage分两种: Session & Local Storage**



**HTML5 两大新离线存储技术：localstorage与Application Cache. + 传统离线存储技术:Cookie.**
**HTML5 两大新离线存储技术：localstorage与Application Cache. + 传统离线存储技术:Cookie.**



　　经过实践我们任务localstorage应该存储一些非关键性ajax数据，做锦上添花的事情；
　　Application Cache用于存储静态资源，仍然是干锦上添花的事情；
　　
cookie只能保存一小段文本（4096字节）；所以不能存储大数据，这是cookie与上述缓存技术的差异之一，而因为HTTP是无状态的，服务器为了区分请求是否来源于同一个服务器，需要一个标识字符串，而这个任务就是cookie完成的，这一段文本每次都会在服务器与浏览器之间传递，以验证用户的权限。


　　所以Application Cache的应用场景不一样，所以使用也不一致。
　　
## Application Cache简介
　　Application Cache的使用要做两方面的工作：
　　① 服务器端需要维护一个manifest清单
　　② 浏览器上只需要一个简单的设置即可









如果你想在用户访问的时候记录或者记住他们的行为，你会想到的是什么，cookie 和session。
但今天告诉你还有两种或者说是1种吧 那就是html5的 LocalStorage 本地存储和 SessionStorage 本地存储基于会话








他们是因为页面开发者的直接行为而产生。所有的缓存数据都由开发者直接完全地掌控。


## AppCache 缓存
AppCache使我们能够有选择的缓冲web浏览器中所有的东西，从页面、图片到脚本、css等等。
尤其在涉及到应用于网站的多个页面上的CSS和JavaScript文件的时候非常有用。其大小目前通常是5M。



## DOM/Web Storage 缓存: Session & Local Storage

如果需要存储一些简单的用key/value对即可解决的数据，DOM Storage是非常完美的方案。
根据作用范围的不同，有Session Storage和Local Storage两种.

两者使用格式都一样，但区别是 
**SessionStorage基于会话，关闭浏览器会消失。而LocalStorage 需要使用销毁：**
**SessionStorage基于会话，关闭浏览器会消失。而LocalStorage 需要使用销毁：**
**SessionStorage基于会话，关闭浏览器会消失。而LocalStorage 需要使用销毁：**

比如用户调整了栏目宽度. 把这个宽度记录到 LocalStorage 中.
下次就从这里读取. 就实现了...  人性化设计.



### Session Storage
会话级别的存储（页面关闭即消失）

### Local Storage
本地化存储（除非主动删除，否则数据永远不会过期）。





## Local Storage 实例
博客 cate/tag/filename/structure 栏目的宽度设置.


### Local Storage 增删查数据
**推荐使用: getItem(), setItem()，removeItem().**
> 如果希望一次性清除所有的键值对，可以使用clear()。
	设置值: 三种方法
	localStorage.a = 3;                 //设置a为"3"
	localStorage["a"] = "sfsf";         //设置a为"sfsf"，覆盖上面的值
	localStorage.setItem("b","isaac");  //设置b为"isaac"
	
	获取值: 三种方法
	var a1 = localStorage.a;            //获取a的值
	var a2 = localStorage["a"];         //获取a的值
	var b = localStorage.getItem("b");  //获取b的值
	
	删除值: 
	localStorage.removeItem("c");       //清除c的值




















[1]:	https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers
[2]:	https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache#%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90 "https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache#一个应用缓存中的资源"